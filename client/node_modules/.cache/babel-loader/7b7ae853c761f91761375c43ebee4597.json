{"ast":null,"code":"/**\n * @author renej\n * NURBS curve object\n *\n * Derives from Curve, overriding getPoint and getTangent.\n *\n * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.\n *\n **/\nimport { Curve, Vector3, Vector4 } from \"../../../build/three.module.js\";\nimport { NURBSUtils } from \"../curves/NURBSUtils.js\";\n/**************************************************************\n *\tNURBS curve\n **************************************************************/\n\nvar NURBSCurve = function (degree, knots\n/* array of reals */\n, controlPoints\n/* array of Vector(2|3|4) */\n, startKnot\n/* index in knots */\n, endKnot\n/* index in knots */\n) {\n  Curve.call(this);\n  this.degree = degree;\n  this.knots = knots;\n  this.controlPoints = []; // Used by periodic NURBS to remove hidden spans\n\n  this.startKnot = startKnot || 0;\n  this.endKnot = endKnot || this.knots.length - 1;\n\n  for (var i = 0; i < controlPoints.length; ++i) {\n    // ensure Vector4 for control points\n    var point = controlPoints[i];\n    this.controlPoints[i] = new Vector4(point.x, point.y, point.z, point.w);\n  }\n};\n\nNURBSCurve.prototype = Object.create(Curve.prototype);\nNURBSCurve.prototype.constructor = NURBSCurve;\n\nNURBSCurve.prototype.getPoint = function (t) {\n  var u = this.knots[this.startKnot] + t * (this.knots[this.endKnot] - this.knots[this.startKnot]); // linear mapping t->u\n  // following results in (wx, wy, wz, w) homogeneous point\n\n  var hpoint = NURBSUtils.calcBSplinePoint(this.degree, this.knots, this.controlPoints, u);\n\n  if (hpoint.w != 1.0) {\n    // project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)\n    hpoint.divideScalar(hpoint.w);\n  }\n\n  return new Vector3(hpoint.x, hpoint.y, hpoint.z);\n};\n\nNURBSCurve.prototype.getTangent = function (t) {\n  var u = this.knots[0] + t * (this.knots[this.knots.length - 1] - this.knots[0]);\n  var ders = NURBSUtils.calcNURBSDerivatives(this.degree, this.knots, this.controlPoints, u, 1);\n  var tangent = ders[1].clone();\n  tangent.normalize();\n  return tangent;\n};\n\nexport { NURBSCurve };","map":{"version":3,"sources":["/Users/carloscarrasquillo/node_modules/three/examples/jsm/curves/NURBSCurve.js"],"names":["Curve","Vector3","Vector4","NURBSUtils","NURBSCurve","degree","knots","controlPoints","startKnot","endKnot","call","length","i","point","x","y","z","w","prototype","Object","create","constructor","getPoint","t","u","hpoint","calcBSplinePoint","divideScalar","getTangent","ders","calcNURBSDerivatives","tangent","clone","normalize"],"mappings":"AAAA;;;;;;;;;AAUA,SACCA,KADD,EAECC,OAFD,EAGCC,OAHD,QAIO,gCAJP;AAKA,SAASC,UAAT,QAA2B,yBAA3B;AAGA;;;;AAIA,IAAIC,UAAU,GAAG,UAAWC,MAAX,EAAmBC;AAAM;AAAzB,EAA+CC;AAAc;AAA7D,EAA2FC;AAAU;AAArG,EAA2HC;AAAQ;AAAnI,EAA0J;AAE1KT,EAAAA,KAAK,CAACU,IAAN,CAAY,IAAZ;AAEA,OAAKL,MAAL,GAAcA,MAAd;AACA,OAAKC,KAAL,GAAaA,KAAb;AACA,OAAKC,aAAL,GAAqB,EAArB,CAN0K,CAO1K;;AACA,OAAKC,SAAL,GAAiBA,SAAS,IAAI,CAA9B;AACA,OAAKC,OAAL,GAAeA,OAAO,IAAM,KAAKH,KAAL,CAAWK,MAAX,GAAoB,CAAhD;;AACA,OAAM,IAAIC,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGL,aAAa,CAACI,MAAnC,EAA2C,EAAGC,CAA9C,EAAkD;AAEjD;AACA,QAAIC,KAAK,GAAGN,aAAa,CAAEK,CAAF,CAAzB;AACA,SAAKL,aAAL,CAAoBK,CAApB,IAA0B,IAAIV,OAAJ,CAAaW,KAAK,CAACC,CAAnB,EAAsBD,KAAK,CAACE,CAA5B,EAA+BF,KAAK,CAACG,CAArC,EAAwCH,KAAK,CAACI,CAA9C,CAA1B;AAEA;AAED,CAlBD;;AAqBAb,UAAU,CAACc,SAAX,GAAuBC,MAAM,CAACC,MAAP,CAAepB,KAAK,CAACkB,SAArB,CAAvB;AACAd,UAAU,CAACc,SAAX,CAAqBG,WAArB,GAAmCjB,UAAnC;;AAGAA,UAAU,CAACc,SAAX,CAAqBI,QAArB,GAAgC,UAAWC,CAAX,EAAe;AAE9C,MAAIC,CAAC,GAAG,KAAKlB,KAAL,CAAY,KAAKE,SAAjB,IAA+Be,CAAC,IAAK,KAAKjB,KAAL,CAAY,KAAKG,OAAjB,IAA6B,KAAKH,KAAL,CAAY,KAAKE,SAAjB,CAAlC,CAAxC,CAF8C,CAE4D;AAE1G;;AACA,MAAIiB,MAAM,GAAGtB,UAAU,CAACuB,gBAAX,CAA6B,KAAKrB,MAAlC,EAA0C,KAAKC,KAA/C,EAAsD,KAAKC,aAA3D,EAA0EiB,CAA1E,CAAb;;AAEA,MAAKC,MAAM,CAACR,CAAP,IAAY,GAAjB,EAAuB;AAEtB;AACAQ,IAAAA,MAAM,CAACE,YAAP,CAAqBF,MAAM,CAACR,CAA5B;AAEA;;AAED,SAAO,IAAIhB,OAAJ,CAAawB,MAAM,CAACX,CAApB,EAAuBW,MAAM,CAACV,CAA9B,EAAiCU,MAAM,CAACT,CAAxC,CAAP;AAEA,CAhBD;;AAmBAZ,UAAU,CAACc,SAAX,CAAqBU,UAArB,GAAkC,UAAWL,CAAX,EAAe;AAEhD,MAAIC,CAAC,GAAG,KAAKlB,KAAL,CAAY,CAAZ,IAAkBiB,CAAC,IAAK,KAAKjB,KAAL,CAAY,KAAKA,KAAL,CAAWK,MAAX,GAAoB,CAAhC,IAAsC,KAAKL,KAAL,CAAY,CAAZ,CAA3C,CAA3B;AACA,MAAIuB,IAAI,GAAG1B,UAAU,CAAC2B,oBAAX,CAAiC,KAAKzB,MAAtC,EAA8C,KAAKC,KAAnD,EAA0D,KAAKC,aAA/D,EAA8EiB,CAA9E,EAAiF,CAAjF,CAAX;AACA,MAAIO,OAAO,GAAGF,IAAI,CAAE,CAAF,CAAJ,CAAUG,KAAV,EAAd;AACAD,EAAAA,OAAO,CAACE,SAAR;AAEA,SAAOF,OAAP;AAEA,CATD;;AAWA,SAAS3B,UAAT","sourcesContent":["/**\n * @author renej\n * NURBS curve object\n *\n * Derives from Curve, overriding getPoint and getTangent.\n *\n * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.\n *\n **/\n\nimport {\n\tCurve,\n\tVector3,\n\tVector4\n} from \"../../../build/three.module.js\";\nimport { NURBSUtils } from \"../curves/NURBSUtils.js\";\n\n\n/**************************************************************\n *\tNURBS curve\n **************************************************************/\n\nvar NURBSCurve = function ( degree, knots /* array of reals */, controlPoints /* array of Vector(2|3|4) */, startKnot /* index in knots */, endKnot /* index in knots */ ) {\n\n\tCurve.call( this );\n\n\tthis.degree = degree;\n\tthis.knots = knots;\n\tthis.controlPoints = [];\n\t// Used by periodic NURBS to remove hidden spans\n\tthis.startKnot = startKnot || 0;\n\tthis.endKnot = endKnot || ( this.knots.length - 1 );\n\tfor ( var i = 0; i < controlPoints.length; ++ i ) {\n\n\t\t// ensure Vector4 for control points\n\t\tvar point = controlPoints[ i ];\n\t\tthis.controlPoints[ i ] = new Vector4( point.x, point.y, point.z, point.w );\n\n\t}\n\n};\n\n\nNURBSCurve.prototype = Object.create( Curve.prototype );\nNURBSCurve.prototype.constructor = NURBSCurve;\n\n\nNURBSCurve.prototype.getPoint = function ( t ) {\n\n\tvar u = this.knots[ this.startKnot ] + t * ( this.knots[ this.endKnot ] - this.knots[ this.startKnot ] ); // linear mapping t->u\n\n\t// following results in (wx, wy, wz, w) homogeneous point\n\tvar hpoint = NURBSUtils.calcBSplinePoint( this.degree, this.knots, this.controlPoints, u );\n\n\tif ( hpoint.w != 1.0 ) {\n\n\t\t// project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)\n\t\thpoint.divideScalar( hpoint.w );\n\n\t}\n\n\treturn new Vector3( hpoint.x, hpoint.y, hpoint.z );\n\n};\n\n\nNURBSCurve.prototype.getTangent = function ( t ) {\n\n\tvar u = this.knots[ 0 ] + t * ( this.knots[ this.knots.length - 1 ] - this.knots[ 0 ] );\n\tvar ders = NURBSUtils.calcNURBSDerivatives( this.degree, this.knots, this.controlPoints, u, 1 );\n\tvar tangent = ders[ 1 ].clone();\n\ttangent.normalize();\n\n\treturn tangent;\n\n};\n\nexport { NURBSCurve };\n"]},"metadata":{},"sourceType":"module"}